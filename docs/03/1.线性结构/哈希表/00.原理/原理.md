# 哈希表

## 一、标准定义
1. 基于数组。
2. 通过哈希函数进行对下标值的一种变换，获取HashCode

## 二、与数组相比
### 1.哈希表的优点
* 快速的插入-删除-查找操作
* 插入和删除值都只需O(1)的时间级
* 查找速度比树还要快，编码比树简单

### 2.哈希表的缺点
* 数据是没有顺序的，不能有序(如从小到大)来遍历其中的元素
* key是不允许重复的，不能放置相同的key，用于保存不同的元素。

## 三、哈希表案例
### 1.案例1
公司想要存储1000个人的信息，每一个工号对应一个员工的信息。若使用数组，增删数据时比较麻烦；使用链表，获取数据时比较麻烦。有没有一种数据结构，能把**某一员工的姓名转换为它对应的工号**，再根据工号查找该员工的完整信息呢？没错此时就可以使用哈希表的哈希函数来实现。

#### **1.1 将字符转化成大数字**
  方式一：数字相加。例如cats转化为数字：3+1+20+19=43，那么就把43作为cats单词的下标值储存在数组中；**产生的数组下标太少**。

  方式二：幂的连乘。我们平时使用的大于10的数字，就是用幂的连乘来表示它的唯一性的。比如： 6543=6 * 10<sup>3</sup> + 5 * 10<sup>2</sup> + 4 * 10 + 3；这样单词也可以用该种方式来表示：cats = 3 * 27<sup>3</sup> + 1 * 27<sup>2</sup> + 20 * 27 + 17 =60337；**产生的数组下标太多**。

#### **1.2 哈希函数**

  **哈希化：将大数字转化成数组范围内下标的过程，称之为哈希化；**

  **哈希函数：将字符转化成大数字，把大数字进行哈希化的代码实现放在一个函数中，该函数就称为哈希函数；**

  **哈希表：对最终数据插入的数组进行整个结构的封装，得到的就是哈希表。**

存在的问题：哈希化过后的下标依然可能重复，这种情况称为冲突，冲突是不可避免的，我们只能解决冲突。
 

## 四、解决冲突
### 1.链地址法（拉链法）

   如下图所示，哈希函数为将每一个数字都对10进行取余操作，则余数的范围0~9作为数组的下标值。

   数组每一个下标值对应的位置存储的不再是一个数字了，而是存储由经过取余操作后得到相同余数的数字组成的**数组或链表**。

   根据下标值获取到冲突对应的整个数组或链表，之后继续在数组或链表中查找就可以了。适用于产生冲突的元素较少。

  <img width="660px"   src="00.img\哈希表原理\哈希原理1.png">

  **解决思路：**
  * 每个数组单元中存储的不再是单个数据，而是一条链条，
  * 这条链条常使用的数据结构为数组或链表，两种数据结构查找的效率相当（因为链条的元素一般不会太多）。

链地址法随着装填因子的增加，平均探测长度呈线性增长，较为平缓。在开发中使用链地址法较多

### 2.开放地址法
  开放地址法是**寻找空白的单元格**来放置冲突的数据项。

  <img width="660px"   src="00.img\哈希表原理\哈希原理2.png">

  根据探测空白单元格位置方式的不同，可分为三种方法：
  * 2.1 线性探测
  * 2.2 二次探测
  * 2.3 再哈希法

三种方法中，线性探测随装填因子的增大，平均探测长度呈指数形式增长，性能较差。

二次探测和再哈希法性能相当，它们的性能比线性探测略好。随着装填因子的变大，平均探测长度呈指数形式增长，需要探测的次数也呈指数形式增长，性能不高。

#### **2.1 线性探测**
##### 2.1.1 线性探测流程
* 当插入13时：
  * 经过哈希化（对10取余）之后得到的下标值index=3，但是该位置已经放置了数据33。
  * 线性探测就是从index位置+1开始向后一个一个来查找合适的位置来放置13，
  * 所谓合适的位置指的是空的位置，如上图中index=4的位置就是合适的位置。

* 当查询13时：

  * 首先13经过哈希化得到index=3，如果index=3的位置存放的数据与需要查询的数据13相同，就直接返回；
  * 不相同时，则线性查找，从index+1位置开始一个一个位置地查找数据13；
  * 查询过程中不会遍历整个哈希表，只要查询到空位置，就停止，因为插入13时不会跳过空位置去插入其他位置。

* 当删除13时：
  * 删除操作和上述两种情况类似；
  * 删除一个数据项时，不能将该位置下标的内容设置为null，否则会影响到之后其他的查询操作，因为一遇到为null的位置就会停止查找。
  * 通常删除一个位置的数据项时，我们可以将它进行特殊处理（比如设置为-1），这样在查找时遇到-1就知道要继续查找。

**装填因子：**
  * 装填因子表示当前哈希表中已经包含的数据项和整个哈希表长度的比值；
  * 装填因子 = 总数据项 / 哈希表长度；
  * 开放地址法的装填因子最大为1，因为只有空白的单元才能放入元素；
  * 链地址法的装填因子可以大于1，因为只要愿意，拉链法可以无限延伸下去；

##### 2.1.2 线性探测问题
* **聚集**:插入冲突数据时，index下面的位置已连续存放多组数据，这种一连串填充单元就称为聚集。
  * 聚集会影响哈希表的性能，无论是插入/查询/删除都会影响；
  * 二次探测法可以一定程度解决该问题。

#### **2.2 二次探测**
##### 2.2.1 线性探测流程
对步长进行了优化，比如从下标值x开始探测：x+2<sup>2</sup>、x+2<sup>2</sup>、x+3<sup>3</sup>。
这样**一次性探测比较长的距离**，避免了数据聚集带来的影响。

##### 2.2.2 线性探测问题
当插入数据分布性较大的一组数据时，比如：13-163-63-3-213，
这种情况会造成**步长不一的一种聚集**（虽然这种情况出现的概率较线性探测的聚集要小），同样会影响性能。

#### **2.3 再哈希法**
在开放地址法中寻找空白单元格的**最好的解决方式为再哈希化**。
##### 2.3.1 再哈希法流程
再哈希法的做法为：把关键字用另一个哈希函数，再做一次哈希化，用这次哈希化的结果作为该关键字的步长。
* 满足条件
  * 和第一个哈希函数不同，不然哈希化后的结果仍是原来位置；
  * 不能输出为0，否则每次探测都是原地踏步的死循环；

* 优秀的哈希函数：stepSize = constant - （key % constant）；
  * 其中constant是质数，且小于数组的容量；
  * 例如：stepSize = 5 - （key % 5），满足需求，并且结果不可能为0；

* 哈希化的效率
  * 哈希表中执行插入和搜索操作效率是非常高的。
  * 如果没有发生冲突，那么效率就会更高；
  * 如果发生冲突，存取时间就依赖后来的探测长度；
  * 平均探测长度以及平均存取时间，取决于填装因子，随着填装因子变大，探测长度会越来越长。

## 五、优秀的哈希函数
哈希表的优势在于它的速度，所以哈希函数不能采用消耗性能较高的复杂算法，**尽量减少乘法和除法**。
哈希函数应尽量做到**快速的计算，均匀的分布**；
### 1.优秀的哈希函数的要求
### 1.1 快速的计算
霍纳法则(秦久韶算法):把求n次多项式f(x)的值就转化为求n个一次多项式的值。

  <img width="660px"   src="00.img\哈希表原理\哈希原理3.png">

* 变换之前：
  * 乘法次数：n（n+1）/2次；
  * 加法次数：n次；

* 变换之后：
  * 乘法次数：n次；
  * 加法次数：n次；

如果使用大O表示时间复杂度的话，直接从变换前的O(N<sup>2</sup>)降到了O(N)

### 1.2 均匀的分布
* 为了保证数据在哈希表中均匀分布，需要使用常量的地方，尽量使用质数；比如：哈希表的长度、N次幂的底数等。
* Java中的HashMap采用的是链地址法，哈希化采用的是公式为：index = HashCode（key）&（Length-1）。计算机直接运算二进制数据，效率更高。
* 但是JavaScript在进行叫大数据的与运算时会出现问题，所以以下使用JavaScript实现哈希化时还是采用取余运算。